---
title: Advanced Error Handling with Custom Error Types
description: Learn how to enhance error handling in go-errors using custom error types for better type safety and context.
---

# Custom Error Types

One of the powerful features of **go-errors** is its support for custom error types. By defining your own error classes, you can create more type-safe and context-rich error handling logic. This section explores various examples of using custom error types to enhance your error management strategy.

## 1. Defining Basic Custom Error Types

You can start by creating simple custom error classes that extend the built-in `Error` class. This allows you to add specific properties or behaviors relevant to your application's domain.

```typescript
import { goSync, goFetch } from 'go-errors';

// Define custom error types
class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public value: unknown // Add context-specific properties
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

class NetworkError extends Error {
  constructor(message: string, public errorCode?: number) { // Add context-specific properties
    super(message);
    this.name = 'NetworkError';
  }
}

// Example of using custom error types with goSync
function validateUserName(name: unknown): [string | null, ValidationError | null] {
  let [validatedName, err] = goSync<string, ValidationError>(() => {
    if (typeof name !== 'string' || name.length < 3) {
      throw new ValidationError(
        'Username must be at least 3 characters long',
        'username',
        name
      );
    }
    return name;
  });

  if (err) {
    console.error(`Validation Error on field '${err.field}':`, err.message);
    return [null, err];
  }

  return [validatedName, null];
}

// Example of using custom error types with goFetch
async function fetchUser(id: string): Promise<[User | null, NetworkError | null]> {
  let [user, err] = await goFetch<User, NetworkError>(`/api/users/${id}`, {
    errorTransformer: (error: any) => {
      if (error instanceof Response) {
        return new NetworkError(\`Failed to fetch user data: HTTP ${error.status} - ${error.statusText}\`, error.status);
      }
      return new NetworkError('Failed to fetch user data due to a network issue.');
    }
  });

  if (err) {
    console.error('Network Error:', err.message, err.errorCode ? `(Code: ${err.errorCode})` : '');
    return [null, err];
  }

  return [user, null];
}
```

This example demonstrates how to create `ValidationError` and `NetworkError` classes with additional properties like `field`, `value`, and `errorCode` to provide more context about the error.

## 2. Creating Error Type Hierarchies

For more complex applications, you might benefit from creating hierarchies of error types. This allows for more granular error handling and type checking.

```typescript
import { goSync, goFetch } from 'go-errors';

// Base application error
class AppError extends Error {
  constructor(message: string, public errorCode: string, public details?: any) {
    super(message);
    this.name = 'AppError';
  }
}

// Specific error types inheriting from AppError
class DatabaseError extends AppError {
  constructor(message: string, details?: any) {
    super(message, 'DATABASE_ERROR', details);
    this.name = 'DatabaseError';
  }
}

class AuthenticationError extends AppError {
  constructor(message: string) {
    super(message, 'AUTHENTICATION_ERROR');
    this.name = 'AuthenticationError';
  }
}

interface Session { isValid: boolean; token: string | null }
interface UserData { id: string; name: string }

// Example using error hierarchies
async function getUserData(userId: string): Promise<[UserData | null, AppError | null]> {
  // Simulate authentication check
  let [session, authErr] = goSync<Session, AuthenticationError>(() => {
    const token = localStorage.getItem('authToken');
    if (!token) {
      throw new AuthenticationError('Authentication token missing.');
    }
    return { isValid: true, token };
  });
  if (authErr) {
    console.error('Authentication Error:', authErr.message);
    return [null, authErr];
  }

  // Fetch user data (simplified fetch for example)
  let [userData, dbErr] = await goFetch<UserData, DatabaseError>(`/api/users/${userId}`, { // Assume goFetch is configured to return DatabaseError
    errorTransformer: (error: any) => new DatabaseError('Database query failed.', error)
  });
  if (dbErr) {
    console.error('Database Error:', dbErr.message, dbErr.details);
    return [null, dbErr];
  }

  return [userData, null];
}

async function main() {
  let [userData, error] = await getUserData('123');
  if (error) {
    if (error instanceof AuthenticationError) {
      // Handle authentication error specifically
      console.log('Authentication required:', error.message);
    } else if (error instanceof DatabaseError) {
      // Handle database errors
      console.error('Database issue:', error.message, error.details);
    } else if (error instanceof AppError) {
      // Handle other AppErrors
      console.error('Application error:', error.message, error.errorCode);
    } else {
      // Fallback for unknown errors
      console.error('An unexpected error occurred:', error.message);
    }
  } else {
    console.log('User data:', userData);
  }
}

main();
```

This example demonstrates creating an `AppError` base class and extending it with `DatabaseError` and `AuthenticationError`. This hierarchy allows for specific error handling based on the error type.

## 3. Adding Context to Errors

Custom error types can be enhanced by adding context-specific properties, which provide valuable information for debugging and error reporting.

```typescript
import { goSync } from 'go-errors';

interface ValidationContext {
  field: string;
  value: unknown;
  constraint: string;
}

class ValidationError extends Error {
  constructor(message: string, public context: ValidationContext) {
    super(message);
    this.name = 'ValidationError';
  }
}

function validateInput(input: any): [string | null, ValidationError | null] {
  let [validatedInput, err] = goSync<string, ValidationError>(() => {
    if (typeof input !== 'string' || input.length < 5) {
      throw new ValidationError(
        'Input must be a string of at least 5 characters',
        { field: 'inputField', value: input, constraint: 'minLength:5' }
      );
    }
    return input;
  });

  if (err instanceof ValidationError) {
    console.error(`Validation Error: ${err.message} - Field: ${err.context.field}, Value: ${err.context.value}`);
    // You can access specific context properties for detailed error reporting
  }

  return [validatedInput, err];
}

// Usage
let [validInput, validationError] = validateInput('test');
if (validationError) {
  console.error('Input validation failed:', validationError.message);
  console.log('Context:', validationError.context); // Access detailed context
} else {
  console.log('Valid input:', validInput);
}
```

In this example, `ValidationError` includes a `context` property of type `ValidationContext`, which provides details about the validation failure, such as the field, the invalid value, and the constraint that was violated.

## Best Practices for Custom Error Types

- **Be Specific:** Create error types that are specific to your application's domain and error scenarios.
- **Add Context:** Include context-rich properties in your error types to provide detailed error information.
- **Use Hierarchies:** Organize your error types into hierarchies for better categorization and handling of errors.
- **Type Your Results:**  Always use the custom error types in your `Result<T, E>` type definitions to enforce type safety.
- **Consistent Transformation:** When using `goFetch`, leverage `errorTransformer` to consistently transform API errors into your custom error types.

## Next Steps

- **[Error Handling Guide](/docs/guides/error-handling):** Explore comprehensive guides on different error handling patterns and strategies.
- **[API Reference for Types](/docs/api-reference/types):**  Review the API documentation for the `Result` type and other related types.
- **[Examples on Error Propagation](/docs/examples/error-propagation):**  Learn how to effectively propagate and handle errors in complex workflows.
