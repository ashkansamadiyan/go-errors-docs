---
title: Core Concepts
description: Dive into the core concepts of go-errors: Result type, goSync, go, and goFetch.
---

# Core Concepts of go-errors

To effectively use **go-errors**, it's essential to understand its core concepts. This section will guide you through the fundamental building blocks of the library: the `Result` type and the core functions: `goSync`, `go`, and `goFetch`.

## 1. The Result Type: Encapsulating Success or Failure

The cornerstone of **go-errors** is the `Result` type. It's designed to represent the outcome of an operation that can either succeed with a value or fail with an error, all within a single, type-safe construct.

```typescript
type Result<T, E = Error> = readonly [T, null] | readonly [null, E];
```

**Key Features of the `Result` Type:**

- **Tuple-Based:**  It's a TypeScript tuple, specifically an array with two elements.
- **Two Possible States:**  A `Result` can be in one of two states:
    - **Success:** Represented as `[value: T, error: null]`. The first element holds the successful value of type `T`, and the second element is always `null`.
    - **Failure:** Represented as `[value: null, error: E]`. The first element is `null`, and the second element holds the error of type `E`.
- **Readonly:**  The tuple is `readonly`, ensuring immutability and preventing accidental modifications.
- **Type Safety:**  Using generics, `Result<T, E>` enforces type safety for both the success value (`T`) and the error type (`E`). The error type defaults to `Error` but can be customized.

**Benefits of Using `Result`:**

- **Explicit Error Handling:**  The `Result` type forces you to explicitly handle both success and error scenarios.
- **Improved Code Clarity:**  It makes the potential for errors explicit in function signatures and return types.
- **Type Safety:**  TypeScript's type system ensures that you are working with the correct types in both success and error cases.

## 2. Core Functions: `goSync`, `go`, and `goFetch`

**go-errors** provides three core functions that wrap operations and return `Result` tuples, making error handling consistent and straightforward across different types of operations.

### `goSync<T, E = Error>(fn: () => T): Result<T, E>`

- **Purpose:**  Wraps synchronous functions that might throw errors.
- **Input:**  A synchronous function `fn` that returns a value of type `T` or throws an error.
- **Output:**  A `Result<T, E>` tuple.
- **Usage:**  Use `goSync` to handle synchronous operations where you want to avoid try-catch blocks and use the `Result` type for error management.

**Example:**

```typescript
import { goSync } from 'go-errors';

function parseJson(jsonString: string): any {
  return JSON.parse(jsonString); // Might throw SyntaxError
}

let [data, err] = goSync(() => parseJson('{"key": "value"}'));

if (err) {
  console.error("JSON parsing failed:", err.message);
} else {
  console.log("Parsed JSON data:", data);
}
```

### `go<T, E = Error>(promise: Promise<T>): Promise<Result<T, E>>`

- **Purpose:**  Wraps asynchronous operations (Promises) that might reject.
- **Input:**  A `Promise<T>` that resolves to a value of type `T` or rejects with an error.
- **Output:**  A `Promise<Result<T, E>>` that resolves to a `Result<T, E>` tuple.
- **Usage:**  Use `go` to handle asynchronous operations, such as API calls or any Promise-based operation, in a Go-style error handling manner.

**Example:**

```typescript
import { go } from 'go-errors';

async function fetchData(): Promise<string> {
  const response = await fetch('/api/data');
  if (!response.ok) {
    throw new Error(\`HTTP error! status: ${response.status}\`);
  }
  return response.text();
}

async function main() {
  let [textData, fetchErr] = await go(fetchData());

  if (fetchErr) {
    console.error("Data fetching failed:", fetchErr.message);
  } else {
    console.log("Fetched data:", textData);
  }
}

main();
```

### `goFetch<T, E = string>(url: string, options?: GoFetchOptions<T, E>): Promise<Result<T, E>>`

- **Purpose:**  An enhanced `fetch` wrapper that simplifies making HTTP requests and handling responses and errors in a type-safe way.
- **Input:**
    - `url`: The URL to fetch.
    - `options` (optional):  `GoFetchOptions<T, E>` to configure request, response transformation, and error transformation.
- **Output:**  A `Promise<Result<T, E>>` that resolves to a `Result<T, E>` tuple, where `T` is the transformed response type, and `E` is the transformed error type (defaulting to `string`).
- **Usage:**  Use `goFetch` for making API requests, taking advantage of its built-in response and error transformation capabilities.

**Example:**

```typescript
import { goFetch } from 'go-errors';

interface ApiResponse {
  data: { message: string };
}

async function getMessage() {
  let [apiResponse, apiError] = await goFetch<ApiResponse>('/api/message', {
    responseTransformer: (data: any) => data as ApiResponse // Transform response data
  });

  if (apiError) {
    console.error("API request failed:", apiError);
  } else {
    console.log("API message:", apiResponse?.data.message);
  }
}

getMessage();
```

## Variable Declaration with `let`

In **go-errors** examples and best practices, you'll often see `let` used for declaring `Result` tuples instead of `const`. This is a stylistic convention, inspired by Go, to allow reusing the error variable name (typically `err`) in sequential operations.

```typescript
// Recommended: Using let for Result tuples
let [value1, err] = goSync(() => operation1());
if (err) {
  handleError(err);
} else {
  processValue1(value1);
}

let [value2, err] = goSync(() => operation2()); // Reusing 'err'
if (err) {
  handleError(err);
} else {
  processValue2(value2);
}
```

While `const` can also be used, `let` aligns more closely with the idiomatic Go error handling style and can improve readability in code with sequential error checks.

## Next Steps

With a solid understanding of these core concepts, you are now ready to explore how to use **go-errors** in practice. Continue with these sections to deepen your knowledge:

- **[Basic Usage Examples](/docs/getting-started/basic-usage):**  See more practical examples of using `goSync`, `go`, and `goFetch`.
- **[API Reference](/docs/api-reference):**  Explore the detailed API documentation for all functions and types.
- **[Guides & Best Practices](/docs/guides):**  Learn about advanced usage patterns and best practices for effective error handling with `go-errors`.
