---
title: Quick Start Guide
description: Learn the basics of go-errors in 5 minutes
---

# Quick Start Guide

This guide will help you get started with go-errors quickly. We'll cover the basic patterns and show you how to handle both synchronous and asynchronous errors effectively.

## Basic Usage

First, import the `go` function from go-errors:

```typescript
import { go } from 'go-errors';
```

### Synchronous Error Handling

Here's a simple example of handling synchronous errors:

```typescript
function divide(a: number, b: number): number {
  if (b === 0) throw new Error("Division by zero");
  return a / b;
}

// Using go-errors
const [result, error] = go(() => divide(10, 0));

if (error) {
  console.log("Failed to divide:", error.message);
  // Handle the error case
} else {
  console.log("Result:", result);
  // Use the result
}
```

### Asynchronous Error Handling

go-errors works seamlessly with async functions and Promises:

```typescript
async function fetchUserData(id: string) {
  const [response, fetchError] = await go(
    fetch(`https://api.example.com/users/${id}`)
  );
  
  if (fetchError) {
    return [null, fetchError] as const;
  }
  
  const [data, parseError] = await go(response.json());
  if (parseError) {
    return [null, parseError] as const;
  }
  
  return [data, null] as const;
}

// Usage
async function main() {
  const [userData, error] = await fetchUserData("123");
  if (error) {
    console.error("Failed to fetch user:", error.message);
    return;
  }
  console.log("User data:", userData);
}
```

## Working with Custom Error Types

You can use custom error types for more specific error handling:

```typescript
class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

function validateUser(user: unknown) {
  if (typeof user !== 'object' || !user) {
    throw new ValidationError('Invalid user object');
  }
  return user;
}

const [user, error] = go<unknown, ValidationError>(() => 
  validateUser({ name: 'John' })
);

if (error) {
  if (error instanceof ValidationError) {
    console.log("Validation failed:", error.message);
  } else {
    console.log("Unknown error:", error.message);
  }
}
```

## Error Propagation

go-errors makes it easy to propagate errors up the call stack:

```typescript
function processStep1() {
  const [result, error] = go(() => {
    // ... some operation that might throw
    return "step1 result";
  });
  if (error) return [null, error] as const;
  return [result, null] as const;
}

function processStep2(input: string) {
  const [result, error] = go(() => {
    // ... process the input
    return "step2 result";
  });
  if (error) return [null, error] as const;
  return [result, null] as const;
}

async function process() {
  const [step1Result, step1Error] = processStep1();
  if (step1Error) {
    return [null, step1Error] as const;
  }

  const [step2Result, step2Error] = processStep2(step1Result);
  if (step2Error) {
    return [null, step2Error] as const;
  }

  return [step2Result, null] as const;
}
```

## Next Steps

Now that you understand the basics, you can:
- Learn about [Core Concepts](/docs/getting-started/core-concepts)
- Explore the [API Reference](/docs/api-reference)
- Check out more [Examples](/docs/examples)
- Read about [Best Practices](/docs/guides/best-practices)
