# Basic Usage Guide

This guide covers the basic usage patterns of the go-errors library. It's designed to help you get started quickly with Go-style error handling in TypeScript/JavaScript.

## Installation

Install the library using bun:

```bash
bun add go-errors
```

## Quick Start

### Basic Error Handling

```typescript
import { goSync, go, goFetch } from 'go-errors';

// Synchronous operation
let [value, err] = goSync(() => {
  if (Math.random() > 0.5) throw new Error('Bad luck!');
  return 42;
});

if (err) {
  console.error('Something went wrong:', err);
} else {
  console.log('Got value:', value);
}

// Asynchronous operation
let [data, err] = await go(someAsyncOperation());
if (err) {
  console.error('Failed:', err);
} else {
  console.log('Got data:', data);
}

// HTTP request with goFetch
let [user, err] = await goFetch<User>('/api/user/123', {
  responseTransformer: (data) => ({
    id: data.id,
    name: `${data.firstName} ${data.lastName}`
  })
});

if (err) {
  console.error('Failed to fetch user:', err);
} else {
  console.log('User:', user);
}
```

## Core Concepts

### The Result Type

The library uses a tuple-based Result type:

```typescript
type Result<T, E = Error> = readonly [T, null] | readonly [null, E];
```

This means every operation returns either:
- `[value, null]` for success
- `[null, error]` for failure

### Variable Declaration

Following Go's convention, always use `let` for result declarations:

```typescript
// ✅ Good: Using let
let [value, err] = goSync(() => someOperation());
if (err) return handleError(err);

let [result, err] = goSync(() => anotherOperation());
if (err) return handleError(err);

// ❌ Bad: Using const
const [value1, error1] = goSync(() => someOperation()); // Less idiomatic
const [value2, error2] = goSync(() => anotherOperation()); // Less idiomatic
```

## Basic Patterns

### Synchronous Operations

```typescript
// Simple value return
let [num, err] = goSync(() => 42);
if (err) {
  console.error(err);
  return;
}
console.log(num); // 42

// With error handling
function divide(a: number, b: number) {
  let [result, err] = goSync(() => {
    if (b === 0) throw new Error('Division by zero');
    return a / b;
  });

  if (err) return [null, err] as const;
  return [result, null] as const;
}

// Usage
let [value, err] = divide(10, 2);
if (err) {
  console.error('Division failed:', err);
  return;
}
console.log('Result:', value); // 5
```

### Asynchronous Operations

```typescript
// With Promises
let [data, err] = await go(Promise.resolve('async data'));
if (err) {
  console.error(err);
  return;
}
console.log(data); // 'async data'

// With async functions
async function fetchUser(id: string) {
  let [user, err] = await goFetch<User>(`/api/users/${id}`);
  if (err) return [null, err] as const;

  return [user, null] as const;
}

// Usage
let [user, err] = await fetchUser('123');
if (err) {
  console.error('Failed to fetch user:', err);
  return;
}
console.log('User:', user);
```

### Error Propagation

```typescript
function validateData(data: unknown) {
  let [validated, err] = goSync(() => {
    if (typeof data !== 'object' || !data) {
      throw new Error('Invalid data type');
    }
    return data;
  });

  if (err) return [null, err] as const;
  return [validated, null] as const;
}

function processData(input: unknown) {
  let [data, err] = validateData(input);
  if (err) return [null, err] as const;

  let [result, err] = goSync(() => {
    // Process the validated data
    return transform(data);
  });

  if (err) return [null, err] as const;
  return [result, null] as const;
}
```

### HTTP Requests with goFetch

```typescript
// Simple GET request
let [data, err] = await goFetch('/api/data');
if (err) {
  console.error('Failed to fetch:', err);
  return;
}
console.log('Got data:', data);

// Typed request with transformers
interface User {
  id: number;
  firstName: string;
  lastName: string;
  fullName: string;
}

let [user, err] = await goFetch<User>('/api/user/1', {
  responseTransformer: (data) => ({
    ...data,
    fullName: `${data.firstName} ${data.lastName}`
  }),
  errorTransformer: (e) => new ApiError(e instanceof Error ? e.message : 'Unknown')
});

if (err) {
  console.error('Failed to fetch user:', err);
  return;
}
console.log('User name:', user.fullName);
```

## Common Use Cases

### Form Validation

```typescript
interface FormData {
  username: string;
  email: string;
  age: number;
}

function validateForm(data: unknown): Result<FormData, Error> {
  let [validated, err] = goSync(() => {
    const form = data as FormData;
    
    if (!form.username) {
      throw new Error('Username is required');
    }
    if (!form.email.includes('@')) {
      throw new Error('Invalid email');
    }
    if (form.age < 18) {
      throw new Error('Must be 18 or older');
    }

    return form;
  });

  return [validated, err] as const;
}

// Usage
let [form, err] = validateForm({
  username: 'john',
  email: 'john@example.com',
  age: 25,
});
```

### File Operations

```typescript
async function readJsonFile(path: string) {
  let [content, err] = await go(fs.readFile(path, 'utf-8'));
  if (err) return [null, err] as const;

  let [data, err] = goSync(() => JSON.parse(content));
  if (err) return [null, err] as const;

  return [data, null] as const;
}

// Usage
let [config, err] = await readJsonFile('config.json');
```

### API Integration

```typescript
interface ApiResponse<T> {
  data: T;
  metadata: {
    timestamp: string;
    version: string;
  };
}

async function fetchApiData<T>(endpoint: string) {
  let [response, err] = await goFetch<ApiResponse<T>>(endpoint, {
    responseTransformer: (data) => ({
      ...data,
      metadata: {
        ...data.metadata,
        receivedAt: new Date().toISOString()
      }
    }),
    errorTransformer: (e) => new ApiError(
      e instanceof Error ? e.message : 'Unknown',
      getErrorCode(e)
    )
  });

  if (err) return [null, err] as const;
  return [response.data, null] as const;
}

// Usage
let [userData, err] = await fetchApiData<User>('/api/user/123');
```

## Best Practices

### 1. Always Check Errors

```typescript
// ✅ Good: Check errors immediately
let [data, err] = goSync(() => operation());
if (err) return handleError(err);

// ❌ Bad: Ignoring errors
let [data, err] = goSync(() => operation());
useData(data); // data might be null!
```

### 2. Use Type Parameters

```typescript
// ✅ Good: Explicit types
let [user, err] = goSync<User, ApiError>(() => fetchUser());

// ❌ Bad: Implicit any
let [data, err] = goSync(() => fetchData());
```

### 3. Consistent Error Handling

```typescript
// ✅ Good: Consistent pattern
function processData(input: string) {
  let [data, err] = goSync(() => parse(input));
  if (err) return [null, err] as const;

  let [result, err] = goSync(() => transform(data));
  if (err) return [null, err] as const;

  return [result, null] as const;
}

// ❌ Bad: Inconsistent pattern
function processData(input: string) {
  try {
    let [data, err] = goSync(() => parse(input));
    if (err) throw err; // Don't mix with try-catch

    return transform(data);
  } catch (error) {
    return null;
  }
}
```

### 4. Early Returns

```typescript
// ✅ Good: Early returns
function processUser(user: User) {
  let [validated, err] = goSync(() => validateUser(user));
  if (err) return [null, err] as const;

  let [processed, err] = goSync(() => processUserData(validated));
  if (err) return [null, err] as const;

  return [processed, null] as const;
}

// ❌ Bad: Nested conditions
function processUser(user: User) {
  let [validated, err] = goSync(() => validateUser(user));
  if (!err) {
    let [processed, err] = goSync(() => processUserData(validated));
    if (!err) {
      return [processed, null] as const;
    }
    return [null, err] as const;
  }
  return [null, err] as const;
}
```

## Related

- [Error Handling Guide](/docs/guides/error-handling) - Advanced error handling patterns
- [HTTP Guide](/docs/guides/http-requests) - Making HTTP requests
- [Type Safety Guide](/docs/guides/type-safety) - Type safety best practices 