---
title: "Understanding go, goSync, and goAsync"
description: "Learn when and how to use each function variant effectively"
---

This guide explains the differences between the three main functions provided by go-errors: `go`, `goSync`, and `goAsync`.

## Overview

```typescript
import { go, goSync, goAsync } from 'go-errors';

// go: Universal function that handles both sync and async operations
let [result1, err1] = await go(operation);

// goSync: Specifically for synchronous operations
let [result2, err2] = goSync(syncOperation);

// goAsync: Specifically for asynchronous operations
let [result3, err3] = await goAsync(asyncOperation);
```

## The `go` Function

The `go` function is the universal solution that handles both synchronous and asynchronous operations.

```typescript
// Handling synchronous operations
let [syncResult, err] = await go(() => {
  return "hello";
});

// Handling asynchronous operations
let [asyncResult, err] = await go(async () => {
  return await fetch("https://api.example.com/data");
});

// Handling promises directly
let [promiseResult, err] = await go(
  Promise.resolve("hello")
);
```

### Type Inference

```typescript
// go infers return types correctly
let [num, err] = await go(() => 42);
// num is number | null
// err is Error | null

let [str, err] = await go(async () => "hello");
// str is string | null
// err is Error | null
```

## The `goSync` Function

`goSync` is optimized for synchronous operations and returns results immediately without requiring `await`.

```typescript
// Basic usage
let [result, err] = goSync(() => {
  return "hello";
});

// Type inference
let [num, err] = goSync(() => 42);
// num is number | null
// err is Error | null

// Error handling
let [result, err] = goSync(() => {
  throw new Error("Something went wrong");
});
// result is null
// err is Error
```

### When to Use `goSync`

1. For purely synchronous operations
2. When you want to avoid the async overhead
3. When you need immediate results without awaiting

```typescript
// ✅ Good use cases for goSync
const [parsed, parseError] = goSync(() => JSON.parse(jsonString));
const [result, mathError] = goSync(() => complexMathCalculation());
const [value, validationError] = goSync(() => validateInput(userInput));
```

## The `goAsync` Function

`goAsync` is specifically designed for handling promises and async operations.

```typescript
// Basic usage
const [result, error] = await goAsync(
  fetch("https://api.example.com/data")
);

// With async functions
const [result, error] = await goAsync(async () => {
  const response = await fetch("https://api.example.com/data");
  return response.json();
});

// Type inference
const [data, err] = await goAsync(Promise.resolve({ id: 1 }));
// data is { id: number } | null
// err is Error | null
```

### When to Use `goAsync`

1. For promise-based operations
2. When working with async/await functions
3. When handling network requests

```typescript
// ✅ Good use cases for goAsync
const [data, fetchError] = await goAsync(fetchData());
const [user, dbError] = await goAsync(database.query());
const [result, streamError] = await goAsync(processStream());
```

## Performance Considerations

### `go` vs `goSync`

```typescript
// ❌ Less efficient: Using go for sync operations
const [result1, error1] = await go(() => syncOperation());

// ✅ More efficient: Using goSync for sync operations
const [result2, error2] = goSync(() => syncOperation());
```

### `go` vs `goAsync`

```typescript
// Both are equally efficient for async operations
const [result1, error1] = await go(asyncOperation());
const [result2, error2] = await goAsync(asyncOperation());
```

## Type Safety

All three functions provide strong TypeScript support:

```typescript
// Type inference works for all functions
const [num1, err1] = goSync(() => 42);
const [num2, err2] = await go(() => 42);
const [num3, err3] = await goAsync(Promise.resolve(42));

// Generic type parameters
interface User {
  id: number;
  name: string;
}

const [user1, err4] = goSync<User>(() => ({ id: 1, name: "John" }));
const [user2, err5] = await go<User>(() => ({ id: 1, name: "John" }));
const [user3, err6] = await goAsync<User>(Promise.resolve({ id: 1, name: "John" }));
```

## Best Practices

1. **Choose the Right Function**
   ```typescript
   // ✅ Good: Using appropriate functions
   const [syncResult] = goSync(() => JSON.parse(data));
   const [asyncResult] = await goAsync(fetch(url));
   const [result] = await go(maybeAsyncOperation());
   ```

2. **Consistent Error Handling**
   ```typescript
   // ✅ Good: Consistent error handling pattern
   const [result, error] = await go(operation());
   if (error) {
     handleError(error);
     return;
   }
   useResult(result);
   ```

3. **Type Safety**
   ```typescript
   // ✅ Good: Explicit typing when needed
   interface ApiResponse<T> {
     data: T;
     meta: { timestamp: number };
   }
   
   const [response, error] = await goAsync<ApiResponse<User>>(
     fetchUser(userId)
   );
   ```

## Related

- [Error Handling Guide](/docs/guides/error-handling) - Basic error handling patterns
- [Async Patterns Guide](/docs/guides/async-patterns) - Advanced async usage
- [Type Safety Guide](/docs/guides/type-safety) - Type safety best practices 